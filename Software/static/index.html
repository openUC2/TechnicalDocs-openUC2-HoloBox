<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HoloBox Camera & Processor</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://pyscript.net/2024.1.1/pyscript.css" />
  <script type="module" src="https://pyscript.net/2024.1.1/pyscript.js"></script>
  <style>
    #stream, #processed { max-width: 100%; border: 1px solid #ccc; margin: 10px; }
    .video-container { display: flex; justify-content: space-around; flex-wrap: wrap; }
    .controls-panel { background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; }
    .slider-container { margin: 10px 0; }
    .processing-status { 
      padding: 10px; 
      margin: 10px 0; 
      border-radius: 4px; 
      background: #e7f1ff; 
      border: 1px solid #b3d9ff;
    }
  </style>
</head>
<body class="bg-light">

<nav class="navbar navbar-dark bg-dark px-3">
  <span class="navbar-brand">HoloBox Camera & Processing</span>
  <div class="d-flex">
    <input id="host" class="form-control me-2" style="width:16rem" placeholder="http://localhost:8000">
    <button id="setHost" class="btn btn-outline-light">Set API URL</button>
  </div>
</nav>

<div class="container-fluid py-4">
  
  <!-- Camera Stream and Processed Output -->
  <div class="video-container">
    <div class="text-center">
      <h5>Original Camera Stream</h5>
      <img id="stream" alt="Stream not running">
    </div>
    <div class="text-center">
      <h5>Fresnel Propagated</h5>
      <canvas id="processed" width="640" height="480"></canvas>
    </div>
  </div>

  <!-- Camera Controls -->
  <div class="controls-panel">
    <h6>Camera Controls</h6>
    <div class="row g-3">
      <div class="col-auto">
        <button id="startBtn" class="btn btn-success">Start Stream</button>
        <button id="stopBtn" class="btn btn-danger">Stop Stream</button>
      </div>
      <div class="col-auto">
        <div class="input-group">
          <span class="input-group-text">Exposure (µs)</span>
          <input id="exposure" type="number" class="form-control" min="1" value="10000">
          <button id="setExposure" class="btn btn-primary">Set</button>
        </div>
      </div>
      <div class="col-auto">
        <div class="input-group">
          <span class="input-group-text">Analogue Gain</span>
          <input id="gain" type="number" step="0.01" class="form-control" min="0" value="1.0">
          <button id="setGain" class="btn btn-primary">Set</button>
        </div>
      </div>
      <div class="col-auto">
        <button id="captureBtn" class="btn btn-warning">Capture JPEG</button>
        <a id="downloadLink" class="btn btn-outline-secondary d-none" download="capture.jpg">Download</a>
      </div>
    </div>
  </div>

  <!-- Hologram Processing Controls -->
  <div class="controls-panel">
    <h6>Hologram Processing Parameters</h6>
    <div class="row g-3">
      <div class="col-md-4">
        <div class="slider-container">
          <label for="wavelength" class="form-label">Wavelength (nm): <span id="wavelength-value">440</span></label>
          <input type="range" class="form-range" id="wavelength" min="380" max="700" value="440" step="10">
        </div>
      </div>
      <div class="col-md-4">
        <div class="slider-container">
          <label for="pixelsize" class="form-label">Pixel Size (µm): <span id="pixelsize-value">1.4</span></label>
          <input type="range" class="form-range" id="pixelsize" min="0.5" max="5.0" value="1.4" step="0.1">
        </div>
      </div>
      <div class="col-md-4">
        <div class="slider-container">
          <label for="dz" class="form-label">Distance (mm): <span id="dz-value">5.0</span></label>
          <input type="range" class="form-range" id="dz" min="0.1" max="20.0" value="5.0" step="0.1">
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-auto">
        <button id="toggleProcessing" class="btn btn-info">Enable Processing</button>
        <button id="processFrame" class="btn btn-secondary">Process Current Frame</button>
      </div>
    </div>
  </div>

  <!-- Status Information -->
  <div class="processing-status">
    <strong>Status:</strong> <span id="status">Ready</span><br>
    <strong>Processing:</strong> <span id="processing-enabled">Disabled</span><br>
    <strong>Last Frame:</strong> <span id="last-processed">None</span>
  </div>

</div>

<!-- PyScript Configuration -->
<py-config>
  packages = ["numpy", "scipy"]
</py-config>

<!-- PyScript Code -->
<py-script>
import numpy as np
from js import document, console, ImageData, Uint8ClampedArray, setInterval, clearInterval
from pyodide.ffi import create_proxy
import asyncio

# Global variables
processing_enabled = False
processing_interval = None
current_wavelength = 440e-9  # nm to m
current_pixelsize = 1.4e-6   # µm to m  
current_dz = 0.005           # mm to m

def abssqr(x):
    """Calculate intensity (what a detector sees)"""
    return np.real(x * np.conj(x))

def FT(x):
    """Forward Fourier transform with proper frequency shift"""
    return np.fft.fftshift(np.fft.fft2(x))

def iFT(x):
    """Inverse Fourier transform with proper frequency shift"""
    return np.fft.ifft2(np.fft.ifftshift(x))

def fresnel_propagator(E0, ps, lambda0, z):
    """
    Freespace propagation using Fresnel kernel
    
    Args:
        E0: Initial complex field in x-y source plane
        ps: Pixel size in meters
        lambda0: Wavelength in meters
        z: Distance from sensor to object in meters
    
    Returns:
        Ef: Propagated output field
    """
    upsample_scale = 1
    n = upsample_scale * E0.shape[1]  # Image width in pixels
    grid_size = ps * n                # Grid size in x-direction
    
    # Inverse space (frequency domain)
    fx = np.linspace(-(n-1)/2*(1/grid_size), (n-1)/2*(1/grid_size), n)
    fy = np.linspace(-(n-1)/2*(1/grid_size), (n-1)/2*(1/grid_size), n)
    Fx, Fy = np.meshgrid(fx, fy)
    
    # Fresnel kernel / point spread function
    H = np.exp(1j*(2 * np.pi / lambda0) * z) * np.exp(1j * np.pi * lambda0 * z * (Fx**2 + Fy**2))
    
    # Compute FFT
    E0fft = FT(E0)
    
    # Multiply spectrum with Fresnel phase factor
    G = H * E0fft
    Ef = iFT(G)  # Output after inverse FFT
    
    return Ef

def process_image_data(image_data, width, height):
    """Process image data through Fresnel propagation"""
    try:
        # Convert image data to numpy array
        # ImageData is in RGBA format
        img_array = np.array(image_data).reshape((height, width, 4))
        
        # Convert to grayscale and normalize
        gray = img_array[:, :, 0] * 0.299 + img_array[:, :, 1] * 0.587 + img_array[:, :, 2] * 0.114
        gray = gray / 255.0
        
        # Crop to smaller size for faster processing (power of 2)
        crop_size = min(256, min(height, width))
        start_y = (height - crop_size) // 2
        start_x = (width - crop_size) // 2
        cropped = gray[start_y:start_y + crop_size, start_x:start_x + crop_size]
        
        # Estimate amplitude from intensity
        amplitude = np.sqrt(cropped)
        
        # Apply Fresnel propagation
        propagated = fresnel_propagator(amplitude, current_pixelsize, current_wavelength, current_dz)
        
        # Calculate intensity
        intensity = abssqr(propagated)
        
        # Normalize for display
        intensity = (intensity - np.min(intensity)) / (np.max(intensity) - np.min(intensity))
        intensity = (intensity * 255).astype(np.uint8)
        
        # Resize back to original canvas size
        if crop_size != width or crop_size != height:
            # Simple repeat for upsampling (can be improved with proper interpolation)
            scale_x = width // crop_size
            scale_y = height // crop_size
            intensity = np.repeat(np.repeat(intensity, scale_y, axis=0), scale_x, axis=1)
            
            # Ensure exact size match
            intensity = intensity[:height, :width]
        
        # Convert back to RGBA
        result = np.zeros((height, width, 4), dtype=np.uint8)
        result[:, :, 0] = intensity  # R
        result[:, :, 1] = intensity  # G  
        result[:, :, 2] = intensity  # B
        result[:, :, 3] = 255        # A
        
        return result.flatten()
        
    except Exception as e:
        console.log(f"Processing error: {e}")
        return None

def update_processed_canvas():
    """Update the processed canvas with Fresnel propagation"""
    try:
        # Get the stream image
        stream_img = document.getElementById('stream')
        canvas = document.getElementById('processed')
        ctx = canvas.getContext('2d')
        
        if not stream_img.src or stream_img.naturalWidth == 0:
            return
        
        # Draw the stream image to canvas to get image data
        ctx.drawImage(stream_img, 0, 0, canvas.width, canvas.height)
        
        # Get image data
        image_data = ctx.getImageData(0, 0, canvas.width, canvas.height)
        
        # Process the image
        processed_data = process_image_data(image_data.data, canvas.width, canvas.height)
        
        if processed_data is not None:
            # Create new image data and display
            new_image_data = ImageData.new(Uint8ClampedArray.new(processed_data), canvas.width, canvas.height)
            ctx.putImageData(new_image_data, 0, 0)
            
            # Update status
            document.getElementById('last-processed').textContent = new Date().toLocaleTimeString()
        
    except Exception as e:
        console.log(f"Canvas update error: {e}")

def toggle_processing():
    """Toggle real-time processing on/off"""
    global processing_enabled, processing_interval
    
    processing_enabled = not processing_enabled
    
    if processing_enabled:
        # Start processing every 200ms
        processing_interval = setInterval(create_proxy(update_processed_canvas), 200)
        document.getElementById('toggleProcessing').textContent = 'Disable Processing'
        document.getElementById('processing-enabled').textContent = 'Enabled'
        document.getElementById('status').textContent = 'Processing frames...'
    else:
        # Stop processing
        if processing_interval:
            clearInterval(processing_interval)
        document.getElementById('toggleProcessing').textContent = 'Enable Processing'
        document.getElementById('processing-enabled').textContent = 'Disabled'
        document.getElementById('status').textContent = 'Processing stopped'

def update_parameters():
    """Update processing parameters from sliders"""
    global current_wavelength, current_pixelsize, current_dz
    
    # Update wavelength (nm to m)
    wavelength_nm = float(document.getElementById('wavelength').value)
    current_wavelength = wavelength_nm * 1e-9
    document.getElementById('wavelength-value').textContent = str(int(wavelength_nm))
    
    # Update pixel size (µm to m)
    pixelsize_um = float(document.getElementById('pixelsize').value)
    current_pixelsize = pixelsize_um * 1e-6
    document.getElementById('pixelsize-value').textContent = str(pixelsize_um)
    
    # Update distance (mm to m)
    dz_mm = float(document.getElementById('dz').value)
    current_dz = dz_mm * 1e-3
    document.getElementById('dz-value').textContent = str(dz_mm)

# Set up event listeners
document.getElementById('toggleProcessing').onclick = create_proxy(toggle_processing)
document.getElementById('processFrame').onclick = create_proxy(update_processed_canvas)

# Parameter slider listeners
document.getElementById('wavelength').oninput = create_proxy(update_parameters)
document.getElementById('pixelsize').oninput = create_proxy(update_parameters)
document.getElementById('dz').oninput = create_proxy(update_parameters)

# Initial parameter update
update_parameters()

console.log("PyScript hologram processing initialized")
</py-script>

<script>
// JavaScript for camera controls
let baseUrl = location.origin;

document.getElementById('setHost').onclick = () => {
  const val = document.getElementById('host').value.trim();
  if (val) baseUrl = val.replace(/\/+$/, '');
};

const api = (path, opt = {}) => fetch(baseUrl + path, opt);

const startStream = () => {
  document.getElementById('stream').src = baseUrl + '/stream';
  document.getElementById('status').textContent = 'Stream started';
};

const stopStream = () => {
  document.getElementById('stream').removeAttribute('src');
  document.getElementById('status').textContent = 'Stream stopped';
};

const setExposure = () => {
  const v = parseInt(document.getElementById('exposure').value, 10);
  if (!isNaN(v)) {
    api('/settings', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({exposure_us: v})
    }).then(r => r.json()).then(data => {
      console.log('Exposure set:', data);
      document.getElementById('status').textContent = `Exposure set to ${v}µs`;
    });
  }
};

const setGain = () => {
  const v = parseFloat(document.getElementById('gain').value);
  if (!isNaN(v)) {
    api('/settings', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({gain: v})
    }).then(r => r.json()).then(data => {
      console.log('Gain set:', data);
      document.getElementById('status').textContent = `Gain set to ${v}`;
    });
  }
};

const capture = () => {
  const link = document.getElementById('downloadLink');
  link.classList.add('d-none');
  api('/snapshot')
    .then(r => r.blob())
    .then(b => {
      link.href = URL.createObjectURL(b);
      link.classList.remove('d-none');
      document.getElementById('status').textContent = 'Image captured';
    });
};

// Event listeners
document.getElementById('startBtn').onclick = startStream;
document.getElementById('stopBtn').onclick = stopStream;
document.getElementById('setExposure').onclick = setExposure;
document.getElementById('setGain').onclick = setGain;
document.getElementById('captureBtn').onclick = capture;

// Initialize
document.getElementById('status').textContent = 'Ready - Click Start Stream to begin';
</script>

</body>
</html>